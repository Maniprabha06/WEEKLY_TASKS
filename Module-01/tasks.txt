1.Unix Internals :
    Unix is a multiuser,multitasking OS designed for flexibility and adaptability
    Originally developed in 1960s
    Written in C programming language
    
    Imagine Kernal as a city with two distinct zones.
    User space is a bustling downtown where applications operate (like web browser or text editor)
    Kernal space is like a city control center,which is managed by city council called Kernal where it manages the traffic (I/O) and Security.
    
    When a application needs to access a file. it should  "request" the kernal (the system call)!!
    The kernal then handles actual file access,ensuring security and resource management.

    HANDS-ON:
    - Write a simple C program that uses the write() system call to write a message to the standard output (stdout).
    step 1:
        for installing gcc to run c program...and strace for system call!
        # sudo apt update
        # sudo apt install gcc strace -y
    step 2:
        create a c file to write a program.
        I just created using nano command for terminal based text editor
        # nano demo_program
    step 3:
    program that uses write() system call:
        #include <uinstd.h>
        #include <string.h>
        int main(){
            const char *text="Pre-Onboard Learning Module-01\n";
            write(1,text,strlen(text));  //1 for stdout ,can use 2 for stderr
            return 0;
        }
    Saved the file.
    step 4:
    # gcc demp_program -o demo_program    //create a executable file
    # ./demo_program  //it shows std output 

    - Use the strace command to observe the system calls made by your program.
    # strace ./demo_program  //to trace the system call

    - Explain which parts of the program operate in user space and which parts involve the kernel space.
        #include <uinstd.h>   //user space
        #include <string.h>   //user space
        int main(){           //user space
            const char *text="Pre-Onboard Learning Module-01\n";  //user space
            write(1,text,strlen(text));  // strlen(text)->user space write -> kernal space...starts with user space call that invokes kernal space
            return 0; //user space
        }

    - Extension: Research and explain the difference between a system call and a library function.
    System calls:
        - It is a direct request made by a user program to a OS kernal
        - user space can't directly access the hardware.. so it uses kernal to make request via a system calls
        - It is used when user program needs acces for low level resources like files,memory,devies or processes.
        - it can be traced using strace
        - Direct OS interactions
        eg: write(),read(),open(),fork(),exit(),execve()

    library functions:
        - it's a part of language's standard library
        - convenient wrapper
        - it is a helper function which may or may not internally use system calls
        - faster when compared to system calls.
        - runs entirely in user space
        eg: printf(),malloc(),fopen(),strlen()


2. Processor_speed:
    - The speed at which a processor can execute instructions.
    - processor(CPU) ->chef , instruction per second ->chef's cooking speed , dishes -> operations , recipe -> instructions
    - simple task -> less time, complex task -> more executing time
    - efficient code -> CPU Will Benefits

    HANDS-ON:
    - Write a C program that performs a large number of simple arithmetic operations (e.g., addition, multiplication) in a loop.
        step 1:
            # nano processor_speed.C //a terminal based editor will open
        step 2:
        PROGRAM:
            #include <stdio.h>
            int main(){
                long long int i,result=0;
                for(i=0;i<1000000;i++){
                    result+=i*3;
                }
                printf("result : %lld\n",result);
                return 0;
            }
        step 3:
        # gcc processor_speed.c -o processor_speed //executable file

    - Use the time command to measure the execution time of your program.
        # time ./processor_speed //shows output

    - Modify the program to perform more complex operations or increase the loop iterations.
        # nano processor_speed.C

    Modified PROGRAM:

        for(i=0;i<200000000;i++){
            result+=(i*2)/3 + (i%7);
        }

            # gcc processor_speed.c -o processor_speed
            # time ./processor_speed // shows output with more executing time

    - Measure the new execution time and discuss how the processor's speed affects the overall performance.
        - if I increase the complexity of the operation it results in longer execution time.
        - Optimizing the code can increase the performance of the CPU.
        - The Processor gets benefited from efficient code.


    - Extension: Research and explain CPU clock cycles, and how that relates to instructions per second.
        CLOCK CYCLES:
        - It is the smallest unit of time in the CPU.
        - It is like a heartbeat that tells the CPU when to do something.
        - CPU performs action sync with the Clock cycle.
        - It is measured in Hertz(Hz) or cycles per second.

        INSTRUCTIONS PER SECOND:
        - Instructions per second (IPS) indicate how many instructions a CPU can execute in one second.
        - A higher IPS means the CPU can process more commands in the same amount of time.

                                       Clock speed
        Instruction per second = -----------------------
                                 cycles per Instruction

        CPU runs at 2 GHz and each instruction it takes on average 2 cycles,then

                                    2,000,000,000
        Innstruction per second = ------------------ = 1,000,000,000
                                          2

        - It takes 1 billion Instruction per second.